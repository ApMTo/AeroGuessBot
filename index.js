const express = require("express");
require("dotenv").config();
const bodyParser = require("body-parser");
const TelegramApi = require("node-telegram-bot-api");
const words = require("./words.js");
const token = process.env.TELEGRAM_TOKEN;
const bot = new TelegramApi(token, { polling: false });
const app = express();

let currentWord = "";
let currentPlayerId = null;
let currentPlayerName = "";
let gameActive = false;
let isCanceled = false;
let gameTimeout = null;
let timer = null;

app.use(bodyParser.json());

const checkAdminRights = async (chatId) => {
  try {
    const admins = await bot.getChatAdministrators(chatId);
    return admins.some((admin) => admin.user.username === "AeroGuessBot");
  } catch (err) {
    console.log(err);
    return false;
  }
};

const checkGroup = async (chatId) => {
  try {
    if (chatId < 0) {
      const isAdmin = await checkAdminRights(chatId);
      if (!isAdmin) {
        return {
          message: bot.sendMessage(
            chatId,
            "‚ö†Ô∏è –î–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã –±–æ—Ç—É –Ω—É–∂–Ω–æ –±—ã—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –≥—Ä—É–ø–ø—ã."
          ),
          status: false,
        };
      }
      return { status: true };
    } else if (chatId > 0) {
      return {
        message: bot.sendMessage(
          chatId,
          "‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö."
        ),
        status: false,
      };
    }
  } catch (err) {
    console.log(err);
    return { status: false };
  }
};

bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;

  if (msg.text === "/start") {
    return bot.sendMessage(
      chatId,
      `–ü—Ä–∏–≤–µ—Ç! üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ **AeroGuess Games**! üéÆ
      
    –ó–¥–µ—Å—å —Ç–µ–±—è –∂–¥—ë—Ç –º–Ω–æ–≥–æ –≤–µ—Å—ë–ª—ã—Ö –∏ —É–º–Ω—ã—Ö –∏–≥—Ä —Å –¥—Ä—É–∑—å—è–º–∏ –≤ —á–∞—Ç–µ! üòÑ  
    –ì–æ—Ç–æ–≤ –Ω–∞—á–∞—Ç—å? –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤—å –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç –∏ –≤—ã–±–µ—Ä–∏ –∏–≥—Ä—É!  
      
    üî• **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–≥—Ä—ã**:  
    - **AeroGuess** üß† ‚Äî —É–≥–∞–¥–∞–π —Å–ª–æ–≤–æ –ø–æ –æ–±—ä—è—Å–Ω–µ–Ω–∏—é  
      
    ‚ú® **–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã**:  
    /startgame ‚Äî –ù–∞—á–∞—Ç—å –∏–≥—Ä—É "–ò–≥—Ä—É –≤ —Å–ª–æ–≤–∞"
    /cancelgame ‚Äî –ó–∞–∫–æ–Ω—á–∏—Ç—å –∏–≥—Ä—É  
    /rules ‚Äî –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã
      
    üì© **–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã** ‚Äî –ø–∏—à–∏ –º–Ω–µ –≤ Telegram! [@ApM_To](https://t.me/ApM_To)  
    üëæ **–¢–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª**: [https://t.me/aeroguessclub](https://t.me/aeroguessclub)  
      
    üí¨ **–ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É**: [@ApM_To](https://t.me/ApM_To)  
    üì¢ **–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª**: [AeroGuess Club](https://t.me/aeroguessclub)`,
      {
        parse_mode: "Markdown",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üí¨ –ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É",
                url: "https://t.me/ApM_To",
              },
            ],
            [
              {
                text: "üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª",
                url: "https://t.me/aeroguessclub",
              },
            ],
          ],
        },
      }
    );
  }
});

bot.onText(/\/rules/, (msg) => {
  const chatId = msg.chat.id;

  bot.sendMessage(chatId, "–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É:", {
    reply_markup: {
      inline_keyboard: [
        [
          {
            text: "–ò–≥—Ä–∞ –≤ —Å–ª–æ–≤–∞",
            callback_data: "word_game",
          },
        ],
      ],
    },
  });
});

bot.on("callback_query", (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const { data } = callbackQuery;
  let gameRules;
  if (data === "word_game") {
    gameRules = `üß† –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã AeroGuess:

1Ô∏è‚É£ –î–æ–±–∞–≤—å –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç Telegram.  
2Ô∏è‚É£ –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /startgame –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã.  
3Ô∏è‚É£ –û–¥–∏–Ω –∏–∑ –∏–≥—Ä–æ–∫–æ–≤ –ø–æ–ª—É—á–∞–µ—Ç —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —Å–ª–æ–≤–æ. –ï–≥–æ –∑–∞–¥–∞—á–∞ ‚Äî –æ–±—ä—è—Å–Ω–∏—Ç—å –µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω—ã–º, –Ω–µ –Ω–∞–∑—ã–≤–∞—è –Ω–∞–ø—Ä—è–º—É—é.  
4Ô∏è‚É£ –û—Å—Ç–∞–ª—å–Ω—ã–µ –∏–≥—Ä–æ–∫–∏ –ø—ã—Ç–∞—é—Ç—Å—è —É–≥–∞–¥–∞—Ç—å —Å–ª–æ–≤–æ –≤ —á–∞—Ç–µ.  
5Ô∏è‚É£ –¢–æ—Ç, –∫—Ç–æ —É–≥–∞–¥–∞–µ—Ç –ø–µ—Ä–≤—ã–º, —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–æ–≤—ã–º –æ–±—ä—è—Å–Ω—è—é—â–∏–º.  
6Ô∏è‚É£ –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –≤–≤–µ–¥–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /cancelgame.  

üéâ –≠—Ç–æ –æ—Ç–ª–∏—á–Ω–∞—è –∏–≥—Ä–∞ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ –¥—Ä—É–∑–µ–π, –≥–¥–µ –≤–∞–∂–Ω—ã —Å–∫–æ—Ä–æ—Å—Ç—å, —Å–º–µ–∫–∞–ª–∫–∞ –∏ —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞!`;
    bot.deleteMessage(chatId, callbackQuery.message.message_id);
  }

  bot.sendMessage(chatId, gameRules, {
    reply_markup: {
      inline_keyboard: [
        [{ text: "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data: "back_to_menu" }],
      ],
    },
  });
});

bot.on("callback_query", (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const { data } = callbackQuery;

  if (data === "back_to_menu") {
    bot.deleteMessage(chatId, callbackQuery.message.message_id);
    bot.sendMessage(chatId, "–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É:", {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "–ò–≥—Ä–∞ –≤ —Å–ª–æ–≤–∞",
              callback_data: "word_game",
            },
          ],
        ],
      },
    });
  }
});

bot.onText(/\/startgame/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const userName = msg.from.first_name;
  isCanceled = false;

  const checkGroupAndRole = await checkGroup(chatId);
  if (checkGroupAndRole.status === false) {
    return checkGroupAndRole.message;
  }

  if (gameActive) {
    return bot.sendMessage(chatId, "üü° –ò–≥—Ä–∞ —É–∂–µ –∏–¥—ë—Ç!");
  }

  if (gameTimeout) {
    clearTimeout(gameTimeout);
  }

  currentPlayerId = userId;
  currentPlayerName = userName;
  currentWord = words[Math.floor(Math.random() * words.length)];
  gameActive = true;

  timer = setTimeout(() => {
    bot.sendMessage(chatId, "‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! –ò–≥—Ä–∞ –æ–±–Ω—É–ª—è–µ—Ç—Å—è.");
    resetGame(chatId);
  }, 300 * 1000);

  bot.sendMessage(
    chatId,
    `üé≤ *–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!*\nüë§ *–û–±—ä—è—Å–Ω—è–µ—Ç:* ${currentPlayerName}`,
    {
      parse_mode: "Markdown",
    }
  );

  bot.sendMessage(chatId, "üîí –ù–∞–∂–º–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–æ–≤–æ!", {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üëÄ –ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–æ–≤–æ", callback_data: "show_word" }],
        [{ text: "üîÑ –°–º–µ–Ω–∏—Ç—å —Å–ª–æ–≤–æ", callback_data: "change_word" }],
      ],
    },
  });
});

bot.on("callback_query", (query) => {
  const chatId = query.message.chat.id;
  const userId = query.from.id;

  if (userId !== currentPlayerId) {
    return bot.answerCallbackQuery(query.id, {
      text: "‚ùå –¢–æ–ª—å–∫–æ –≤–µ–¥—É—â–∏–π –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å —Å–ª–æ–≤–æ!",
      show_alert: true,
    });
  }

  if (query.data === "show_word") {
    bot.answerCallbackQuery(query.id, {
      text: `ü§´ –¢–≤–æ—ë —Å–ª–æ–≤–æ: ${currentWord}\n–û–±—ä—è—Å–Ω–∏ –µ–≥–æ, –Ω–æ –Ω–µ –Ω–∞–∑—ã–≤–∞–π –Ω–∞–ø—Ä—è–º—É—é!`,
      show_alert: true,
    });
  } else if (query.data === "change_word") {
    currentWord = words[Math.floor(Math.random() * words.length)];
    bot.answerCallbackQuery(query.id, {
      text: "‚úÖ –°–ª–æ–≤–æ –∏–∑–º–µ–Ω–µ–Ω–æ! –¢–≤–æ—ë –Ω–æ–≤–æ–µ —Å–ª–æ–≤–æ: " + currentWord,
      show_alert: true,
    });
  }
});

bot.on("message", (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text?.toLowerCase();
  const userId = msg.from.id;
  const userName = msg.from.first_name;

  const replyText = msg.reply_to_message?.text?.toLowerCase();

  if (!gameActive || !currentWord) return;

  if (
    (text === currentWord.toLowerCase() ||
      replyText === currentWord.toLowerCase()) &&
    userId === currentPlayerId
  ) {
    resetGame(chatId);
    return bot.sendMessage(
      chatId,
      "üî¥ –í —Å–≤—è–∑–∏ —Å —Ç–µ–º, —á—Ç–æ –≤–µ–¥—É—â–∏–π –æ–∑–≤—É—á–∏–ª –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —Å–ª–æ–≤–æ, –∏–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è!"
    );
  }

  if (
    text === currentWord.toLowerCase() ||
    replyText === currentWord.toLowerCase()
  ) {
    bot.sendMessage(
      chatId,
      `üéâ *${userName} —É–≥–∞–¥–∞–ª(–∞) —Å–ª–æ–≤–æ!* –≠—Ç–æ –±—ã–ª–æ: *${currentWord}*`,
      {
        parse_mode: "Markdown",
      }
    );
    currentPlayerId = userId;
    currentPlayerName = userName;
    currentWord = words[Math.floor(Math.random() * words.length)];

    bot.sendMessage(chatId, `üîÑ –ù–æ–≤—ã–π –≤–µ–¥—É—â–∏–π: *${currentPlayerName}*`, {
      parse_mode: "Markdown",
    });

    bot.sendMessage(chatId, "üîí –ù–∞–∂–º–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–æ–≤–æ!", {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üëÄ –ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–æ–≤–æ", callback_data: "show_word" }],
          [{ text: "üîÑ –°–º–µ–Ω–∏—Ç—å —Å–ª–æ–≤–æ", callback_data: "change_word" }],
        ],
      },
    });

    clearTimeout(timer);
    timer = setTimeout(() => {
      bot.sendMessage(chatId, "‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! –ò–≥—Ä–∞ –æ–±–Ω—É–ª—è–µ—Ç—Å—è.");
      resetGame(chatId);
    }, 300 * 1000);
  }
});

bot.onText("/cancelgame", async (msg) => {
  const chatId = msg.chat.id;

  const checkGroupAndRole = await checkGroup(chatId);
  if (checkGroupAndRole?.status === false) {
    return checkGroupAndRole.message;
  }
  if (!gameActive || isCanceled) {
    return bot.sendMessage(chatId, "üî¥ –ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞!");
  }

  resetGame(chatId);
  return bot.sendMessage(chatId, "üî¥ –ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!");
});

const resetGame = () => {
  currentWord = "";
  currentPlayerId = null;
  currentPlayerName = "";
  gameActive = false;
  isCanceled = true;
  clearTimeout(timer);
};

bot.setMyCommands([
  { command: "/startgame", description: "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É" },
  { command: "/cancelgame", description: "–ó–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É" },
  { command: "/start", description: "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ" },
  { command: "/rulest", description: "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã" },
]);

bot.setWebHook(`${process.env.SERVER_LINK}/webhook`);

app.post("/webhook", (req, res) => {
  const update = req.body;
  bot.processUpdate(update);
  res.sendStatus(200);
});
 
app.get("/ping", (req, res) => {
  res.send("Server is alive");
});

setInterval(() => {
  fetch(`${process.env.SERVER_LINK}/ping`)
    .then((res) => res.text())
    .then((data) => console.log(`Keep-alive: ${data}`))
    .catch((err) => console.error(`Keep-alive error: ${err}`));
}, 9 * 60 * 1000);

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
